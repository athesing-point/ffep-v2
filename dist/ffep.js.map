{
  "version": 3,
  "sources": ["../src/constants.js", "../src/utils.js", "../src/cache.js", "../src/api.js", "../src/ui.js", "../src/formHandler.js", "../src/ffep.js"],
  "sourcesContent": [
    "export const SMARTY_WEBSITE_KEYS = {\n  PDC: \"17448046178191022\",\n  PDD: \"17448045555816402\",\n};\n\nexport const ErrorTypes = {\n  INITIALIZATION: \"FFEP_INITIALIZATION_ERROR\",\n  API: \"FFEP_API_ERROR\",\n  CACHE: \"FFEP_CACHE_ERROR\",\n  FORM_SUBMISSION: \"FFEP_FORM_SUBMISSION_ERROR\",\n};\n",
    "// Enhanced debounce function with variable wait time\nexport function debounce(func, getWaitTime) {\n  let timeout;\n  return function executedFunction(...args) {\n    return new Promise((resolve) => {\n      const later = async () => {\n        clearTimeout(timeout);\n        try {\n          // Add try-catch within the debounced function\n          resolve(await func.apply(this, args));\n        } catch (error) {\n          console.error(\"Error in debounced function execution:\", error);\n          // Decide how to handle the error, e.g., resolve with null or reject\n          resolve(null); // Or reject(error);\n        }\n      };\n      clearTimeout(timeout);\n      // Ensure getWaitTime is called correctly and handles potential errors\n      let wait = 200; // Default wait time\n      try {\n        const query = args[0]; // Assuming the first arg is the query\n        wait = typeof getWaitTime === \"function\" ? getWaitTime(query) : getWaitTime;\n        if (isNaN(wait) || wait < 0) {\n          console.warn(\"Invalid wait time calculated, using default 200ms\");\n          wait = 200;\n        }\n      } catch (error) {\n        console.error(\"Error getting wait time for debounce:\", error);\n        // Use default wait time if calculation fails\n      }\n\n      timeout = setTimeout(later, wait);\n    });\n  };\n}\n",
    "import { ErrorTypes } from \"./constants.js\";\n\n// Configuration Constants (consider moving to constants.js if used elsewhere)\nconst CACHE_PREFIX = \"ffep_cache_\";\nconst MAX_CACHE_ITEMS = 50;\nconst CACHE_EXPIRY_MS = 30 * 60 * 1000; // 30 minutes\n\nexport class CacheManager {\n  constructor() {\n    this.hits = 0;\n    this.misses = 0;\n    this.errors = 0;\n    // Initial cleanup on instantiation\n    this.cleanupCache();\n    // console.log(\"CacheManager Initialized\");\n  }\n\n  getCacheKeys() {\n    try {\n      return Object.keys(sessionStorage)\n        .filter((key) => key.startsWith(CACHE_PREFIX))\n        .map((key) => ({ key, timestamp: this.getItemTimestamp(key) })) // Get timestamp along with key\n        .sort((a, b) => a.timestamp - b.timestamp) // Sort by timestamp ascending (oldest first)\n        .map((item) => item.key); // Return just the keys in sorted order\n    } catch (error) {\n      console.warn(\"Error retrieving cache keys:\", error);\n      this.errors++;\n      return []; // Return empty array on error\n    }\n  }\n\n  getItemTimestamp(key) {\n    try {\n      const item = sessionStorage.getItem(key);\n      if (!item) return 0; // Or handle as error?\n      const parsed = JSON.parse(item);\n      return parsed?.timestamp || 0;\n    } catch (error) {\n      console.warn(`Error parsing timestamp for cache key ${key}:`, error);\n      // Treat as old if parsing fails\n      return 0;\n    }\n  }\n\n  cleanupCache() {\n    try {\n      const cacheKeys = this.getCacheKeys();\n      // console.log(`Running cache cleanup. Current items: ${cacheKeys.length}`);\n      if (cacheKeys.length > MAX_CACHE_ITEMS) {\n        const keysToRemove = cacheKeys.slice(0, cacheKeys.length - MAX_CACHE_ITEMS);\n        // console.log(`Cache limit (${MAX_CACHE_ITEMS}) exceeded. Removing ${keysToRemove.length} oldest items.`);\n        keysToRemove.forEach((key) => {\n          try {\n            sessionStorage.removeItem(key);\n          } catch (removeError) {\n            console.warn(`Failed to remove cache item ${key}:`, removeError);\n            this.errors++;\n          }\n        });\n        // console.log(`Cache Cleanup Complete. Items remaining: ${this.getCacheKeys().length}`);\n      }\n    } catch (error) {\n      // console.warn(\"Cache cleanup failed:\", error);\n      this.errors++;\n    }\n  }\n\n  getCachedItem(key) {\n    const prefixedKey = CACHE_PREFIX + key;\n    try {\n      const item = sessionStorage.getItem(prefixedKey);\n      if (!item) {\n        // console.log(`Cache Miss: ${key}`);\n        this.misses++;\n        return null;\n      }\n\n      const parsed = JSON.parse(item);\n\n      // Check for expiration\n      if (Date.now() - (parsed?.timestamp || 0) > CACHE_EXPIRY_MS) {\n        // console.log(`Cache Expired: ${key}`);\n        try {\n          sessionStorage.removeItem(prefixedKey);\n        } catch (removeError) {\n          console.warn(`Failed to remove expired cache item ${prefixedKey}:`, removeError);\n          this.errors++;\n          this.misses++; // Treat expired as a miss\n          return null;\n        }\n      }\n\n      // console.log(`Cache Hit: ${key}`);\n      this.hits++;\n      return parsed.data;\n    } catch (error) {\n      // console.warn(`Cache retrieval failed for key ${key}:`, error);\n      this.errors++;\n      // Attempt to remove potentially corrupted item\n      try {\n        sessionStorage.removeItem(prefixedKey);\n        // console.log(`Removed potentially corrupted cache item: ${prefixedKey}`);\n      } catch (removeError) {\n        console.warn(`Failed to remove potentially corrupted cache item ${prefixedKey}:`, removeError);\n        // Increment error count again or handle differently?\n      }\n      return null; // Return null on error\n    }\n  }\n\n  setCachedItem(key, data) {\n    const prefixedKey = CACHE_PREFIX + key;\n    const cacheItem = {\n      timestamp: Date.now(),\n      data: data,\n    };\n\n    try {\n      sessionStorage.setItem(prefixedKey, JSON.stringify(cacheItem));\n      // console.log(`Cache Set: ${key}, Items in cache before cleanup: ${this.getCacheKeys().length}`);\n      // Run cleanup *after* setting the item to ensure the new item isn't immediately removed\n      this.cleanupCache();\n      // console.log(`Cache items after cleanup: ${this.getCacheKeys().length}`);\n    } catch (error) {\n      // console.warn(`Cache storage failed for key ${key}:`, error);\n      this.errors++;\n\n      // Handle potential quota exceeded error\n      if (error.name === \"QuotaExceededError\" || (error.code && (error.code === 22 || error.code === 1014))) {\n        console.warn(\"SessionStorage quota likely exceeded. Attempting cleanup and retry...\");\n        try {\n          // More aggressive cleanup: remove a few items regardless of count\n          const keys = this.getCacheKeys();\n          const itemsToRemove = Math.min(5, keys.length); // Remove up to 5 oldest items\n          if (itemsToRemove > 0) {\n            console.log(`Aggressive cleanup: Removing ${itemsToRemove} oldest items.`);\n            keys.slice(0, itemsToRemove).forEach((k) => {\n              try {\n                sessionStorage.removeItem(k);\n              } catch (e) {\n                console.warn(`Error removing item ${k} during aggressive cleanup:`, e);\n              }\n            });\n          }\n\n          // Retry setting the item\n          sessionStorage.setItem(prefixedKey, JSON.stringify(cacheItem));\n          // console.log(`Cache Set Retry Successful: ${key}`);\n          // Run normal cleanup again after successful retry\n          this.cleanupCache();\n        } catch (retryError) {\n          // console.warn(`Cache storage retry failed for key ${key}:`, retryError);\n          this.errors++; // Increment error count again for the retry failure\n        }\n      }\n    }\n  }\n\n  // Optional: Method to get current cache stats\n  getStats() {\n    return {\n      hits: this.hits,\n      misses: this.misses,\n      errors: this.errors,\n      keys: this.getCacheKeys().length, // Provide current key count\n    };\n  }\n}\n",
    "import { ErrorTypes } from \"./constants.js\";\n\n/**\n * Fetches address suggestions from the SmartyStreets API.\n *\n * @param {string} query - The address query.\n * @param {string} smartyKey - The SmartyStreets API key.\n * @param {object} cacheManager - The cache manager instance.\n * @param {object} options - Additional options.\n * @param {string} [options.lastQuery=\"\"] - The last query made (for optimization).\n * @param {number} [options.suggestionsCount=0] - Number of suggestions from the last query.\n * @param {number} [options.apiCallCount=0] - Current API call count for tracking.\n * @param {HTMLElement|null} [options.errorElement=null] - Element to display API errors.\n * @returns {Promise<Array|null>} A promise that resolves to an array of suggestions or null.\n */\nexport async function fetchSuggestions(query, smartyKey, cacheManager, options = {}) {\n  const { lastQuery = \"\", suggestionsCount = 0, apiCallCount = 0, errorElement = null } = options;\n\n  if (!query || query.length < 3) return null;\n\n  try {\n    // Check cache first using CacheManager\n    const cacheKey = query.toLowerCase();\n    const cachedResults = cacheManager.getCachedItem(cacheKey);\n    if (cachedResults) {\n      // console.log(`Using cached results for: ${query}`);\n      return cachedResults.slice(0, 5); // Limit to 5 results\n    }\n\n    // Optimization: Skip API call if extending a query that previously had no results\n    if (lastQuery && query.toLowerCase().startsWith(lastQuery.toLowerCase()) && suggestionsCount === 0) {\n      // console.log(`Skipping API call for: ${query} (extension of no-result query: ${lastQuery})`);\n      return [];\n    }\n\n    const url = `https://us-autocomplete-pro.api.smartystreets.com/lookup?${new URLSearchParams({\n      search: query,\n      key: smartyKey,\n      source: \"all\",\n    })}`;\n\n    const currentApiCallCount = apiCallCount + 1; // Increment count for this call\n    // const cacheStats = cacheManager.getStats();\n    // console.log(`API Call #${currentApiCallCount} for: ${query}`);\n    // console.log(`Cache Stats - Hits: ${cacheStats.hits}, Misses: ${cacheStats.misses}, Errors: ${cacheStats.errors}, Keys: ${cacheStats.keys}`);\n\n    const response = await fetch(url);\n    if (!response.ok) {\n      const error = new Error(`Failed to fetch suggestions: ${response.status} ${response.statusText}`);\n      error.name = ErrorTypes.API;\n      throw error;\n    }\n\n    const data = await response.json();\n    const suggestions = (data.suggestions || []).slice(0, 5); // Limit to 5 results\n\n    // Cache the results using CacheManager\n    cacheManager.setCachedItem(cacheKey, suggestions);\n\n    // Hide error element if it was previously shown\n    if (errorElement) {\n      errorElement.style.display = \"none\";\n    }\n\n    // Return suggestions and updated api call count if needed, or just suggestions\n    return suggestions;\n  } catch (error) {\n    // Ensure error is properly tagged if not already\n    if (!error.name) {\n      error.name = ErrorTypes.API;\n    }\n    console.error(\"Error fetching suggestions:\", error);\n    if (errorElement) {\n      errorElement.textContent = \"Error fetching address suggestions.\"; // More specific error\n      errorElement.style.display = \"block\";\n    }\n    return []; // Return empty array on error to prevent issues downstream\n  }\n}\n",
    "/**\n * Sets up the autocomplete input field and suggestion container event listeners.\n * @param {object} ffepInstance - The main FFEP class instance.\n */\nexport function setupAutocomplete(ffepInstance) {\n  // Find existing autocomplete container created in Webflow\n  ffepInstance.autocompleteContainer = document.querySelector(\".ffep-autocomplete\");\n  if (!ffepInstance.autocompleteContainer) {\n    // console.error(\"Autocomplete container with class 'ffep-autocomplete' not found\");\n    return; // Don't attach listeners if container missing\n  }\n\n  // Setup input event listeners\n  ffepInstance.addressInput.addEventListener(\"input\", ffepInstance.handleInput.bind(ffepInstance));\n  ffepInstance.addressInput.addEventListener(\"keydown\", handleKeydown.bind(null, ffepInstance)); // Bind instance for context\n  ffepInstance.addressInput.addEventListener(\"focus\", handleFocus.bind(null, ffepInstance)); // Bind instance\n  document.addEventListener(\"click\", handleClickOutside.bind(null, ffepInstance)); // Bind instance\n  // Note: Mouseover is handled per-suggestion element in showSuggestions\n}\n\n/**\n * Displays the suggestion list.\n * @param {object} ffepInstance - The main FFEP class instance.\n */\nexport function showSuggestions(ffepInstance) {\n  // console.log(\"Showing suggestions:\", ffepInstance.suggestions);\n  if (!ffepInstance.suggestions || !ffepInstance.suggestions.length) {\n    hideSuggestions(ffepInstance);\n    return;\n  }\n\n  if (!ffepInstance.autocompleteContainer) return;\n\n  const html = ffepInstance.suggestions\n    .map(\n      (suggestion, index) => `\n      <div class=\"ffep-suggestion\" data-index=\"${index}\" role=\"option\" aria-selected=\"false\">\n        ${suggestion.street_line}, ${suggestion.city}, ${suggestion.state} ${suggestion.zipcode}\n      </div>\n    `\n    )\n    .join(\"\");\n\n  ffepInstance.autocompleteContainer.innerHTML = html;\n  ffepInstance.autocompleteContainer.style.display = \"block\";\n  ffepInstance.isAutocompleteVisible = true;\n  ffepInstance.selectedIndex = -1; // Reset selection index\n\n  // Add event listeners to each suggestion\n  ffepInstance.autocompleteContainer.querySelectorAll(\".ffep-suggestion\").forEach((el) => {\n    el.addEventListener(\"click\", () => {\n      clearHoverStates(ffepInstance);\n      const index = parseInt(el.dataset.index);\n      if (!isNaN(index)) {\n        selectSuggestion(ffepInstance, index);\n      } else {\n        console.error(\"Invalid index found on suggestion element:\", el);\n      }\n    });\n\n    el.addEventListener(\"mouseover\", () => {\n      clearHoverStates(ffepInstance);\n      el.classList.add(\"hover\");\n      const index = parseInt(el.dataset.index);\n      if (!isNaN(index)) {\n        ffepInstance.selectedIndex = index; // Update index for potential Enter press\n      }\n    });\n\n    el.addEventListener(\"mouseout\", () => {\n      el.classList.remove(\"hover\");\n      // Consider resetting selectedIndex if mouse leaves container entirely\n    });\n  });\n}\n\n/**\n * Hides the suggestion list.\n * @param {object} ffepInstance - The main FFEP class instance.\n */\nexport function hideSuggestions(ffepInstance) {\n  if (ffepInstance.autocompleteContainer) {\n    ffepInstance.autocompleteContainer.style.display = \"none\";\n    ffepInstance.autocompleteContainer.innerHTML = \"\"; // Clear suggestions\n  }\n  ffepInstance.isAutocompleteVisible = false;\n  ffepInstance.selectedIndex = -1;\n}\n\n/**\n * Clears hover states from suggestions.\n * @param {object} ffepInstance - The main FFEP class instance.\n */\nfunction clearHoverStates(ffepInstance) {\n  if (!ffepInstance.autocompleteContainer) return;\n  ffepInstance.autocompleteContainer.querySelectorAll(\".ffep-suggestion.hover\").forEach((el) => {\n    el.classList.remove(\"hover\");\n    el.setAttribute(\"aria-selected\", \"false\");\n  });\n}\n\n/**\n * Navigates suggestions using arrow keys.\n * @param {object} ffepInstance - The main FFEP class instance.\n * @param {number} direction - +1 for down, -1 for up.\n */\nfunction navigateSuggestions(ffepInstance, direction) {\n  if (!ffepInstance.autocompleteContainer) return;\n  const suggestions = ffepInstance.autocompleteContainer.querySelectorAll(\".ffep-suggestion\");\n  if (!suggestions.length) {\n    ffepInstance.selectedIndex = -1;\n    return;\n  }\n\n  let newIndex = ffepInstance.selectedIndex + direction;\n\n  // Wrap around logic\n  if (newIndex < -1) {\n    // Allow going \"up\" from first item to input state (-1)\n    newIndex = suggestions.length - 1;\n  } else if (newIndex >= suggestions.length) {\n    newIndex = -1; // Allow going \"down\" from last item to input state (-1)\n  }\n  // No extra check needed for newIndex === -1 && direction === -1, handled by wrap logic\n\n  ffepInstance.selectedIndex = newIndex;\n}\n\n/**\n * Updates the visual highlight on suggestions based on selectedIndex.\n * @param {object} ffepInstance - The main FFEP class instance.\n */\nfunction updateHighlight(ffepInstance) {\n  if (!ffepInstance.autocompleteContainer) return;\n  const suggestions = ffepInstance.autocompleteContainer.querySelectorAll(\".ffep-suggestion\");\n\n  suggestions.forEach((el, index) => {\n    el.classList.remove(\"hover\");\n    el.setAttribute(\"aria-selected\", \"false\");\n    if (index === ffepInstance.selectedIndex) {\n      el.classList.add(\"hover\");\n      el.setAttribute(\"aria-selected\", \"true\");\n      el.scrollIntoView({ behavior: \"smooth\", block: \"nearest\" });\n    }\n  });\n  // Removed optional input value update during navigation\n}\n\n/**\n * Handles selecting a suggestion (click or Enter).\n * @param {object} ffepInstance - The main FFEP class instance.\n * @param {number} index - The index of the suggestion to select.\n */\nexport function selectSuggestion(ffepInstance, index) {\n  if (index >= 0 && index < ffepInstance.suggestions.length) {\n    const selectedSuggestion = ffepInstance.suggestions[index];\n    if (selectedSuggestion) {\n      const addressValue = `${selectedSuggestion.street_line}, ${selectedSuggestion.city}, ${selectedSuggestion.state} ${selectedSuggestion.zipcode}`;\n      ffepInstance.addressInput.value = addressValue; // Update input field\n      ffepInstance.lastQuery = addressValue; // Update last query\n      hideSuggestions(ffepInstance); // Hide autocomplete\n\n      // Trigger form submission/navigation logic from the main instance\n      ffepInstance.triggerFormSubmit(); // Call the method responsible for navigation\n    } else {\n      console.error(`Suggestion at index ${index} is invalid.`);\n      hideSuggestions(ffepInstance);\n    }\n  } else {\n    console.error(`Invalid index ${index} for selectSuggestion.`);\n    hideSuggestions(ffepInstance);\n  }\n}\n\n/**\n * Handles keydown events on the address input for navigation and selection.\n * @param {object} ffepInstance - The main FFEP class instance.\n * @param {Event} e - The keydown event.\n */\nfunction handleKeydown(ffepInstance, e) {\n  if (!ffepInstance.isAutocompleteVisible) {\n    // Form submission on Enter when autocomplete is hidden is handled in setupFormHandling\n    return;\n  }\n\n  if (!ffepInstance.autocompleteContainer) return;\n  const suggestions = ffepInstance.autocompleteContainer.querySelectorAll(\".ffep-suggestion\");\n  if (!suggestions || suggestions.length === 0) return;\n\n  switch (e.key) {\n    case \"ArrowUp\":\n    case \"ArrowDown\":\n      e.preventDefault(); // Prevent cursor move/scroll\n      navigateSuggestions(ffepInstance, e.key === \"ArrowUp\" ? -1 : 1);\n      updateHighlight(ffepInstance);\n      break;\n    case \"Enter\":\n      e.preventDefault(); // Prevent default form submission\n      if (ffepInstance.selectedIndex !== -1) {\n        selectSuggestion(ffepInstance, ffepInstance.selectedIndex);\n      } else {\n        // If suggestions visible but none selected, trigger submit with current input\n        hideSuggestions(ffepInstance);\n        ffepInstance.triggerFormSubmit(); // Use the main instance method\n      }\n      break;\n    case \"Escape\":\n      e.preventDefault();\n      hideSuggestions(ffepInstance);\n      break;\n    default:\n      // Allow other keys for input modification\n      break;\n  }\n}\n\n/**\n * Handles clicks outside the input and autocomplete container to hide suggestions.\n * @param {object} ffepInstance - The main FFEP class instance.\n * @param {Event} e - The click event.\n */\nfunction handleClickOutside(ffepInstance, e) {\n  if (ffepInstance.addressInput && !ffepInstance.addressInput.contains(e.target) && ffepInstance.autocompleteContainer && !ffepInstance.autocompleteContainer.contains(e.target)) {\n    hideSuggestions(ffepInstance);\n  }\n}\n\n/**\n * Handles the focus event on the address input.\n * Shows cached suggestions if available and input meets criteria.\n * @param {object} ffepInstance - The main FFEP class instance.\n * @param {Event} e - The focus event.\n */\nasync function handleFocus(ffepInstance, e) {\n  const query = e.target.value;\n  // Only show suggestions on focus if input valid and not already visible\n  if (query.length >= 3 && !ffepInstance.isAutocompleteVisible) {\n    try {\n      const cacheKey = query.toLowerCase();\n      const cachedResults = ffepInstance.cacheManager.getCachedItem(cacheKey);\n\n      if (cachedResults && cachedResults.length > 0) {\n        // console.log(`Reshowing cached results for: ${query} on focus`);\n        ffepInstance.suggestions = cachedResults;\n        showSuggestions(ffepInstance);\n      } else {\n        // Optional: Fetch if cache miss on focus (currently disabled)\n        // const suggestions = await ffepInstance.debouncedFetchSuggestions(query);\n        // if (suggestions && suggestions.length > 0) {\n        //     ffepInstance.suggestions = suggestions;\n        //     showSuggestions(ffepInstance);\n        // }\n      }\n    } catch (error) {\n      console.error(\"Error handling focus event:\", error);\n      if (ffepInstance.errorElement) {\n        ffepInstance.errorElement.textContent = \"Error retrieving suggestions.\";\n        ffepInstance.errorElement.style.display = \"block\";\n      }\n    }\n  } else if (query.length < 3) {\n    hideSuggestions(ffepInstance);\n  }\n}\n",
    "/**\n * Sets up event listeners for form submission (button click and Enter key).\n * It relies on the main FFEP instance to check autocomplete visibility\n * and to trigger the actual submission logic.\n *\n * @param {object} ffepInstance - The main FFEP class instance.\n */\nexport function setupFormEventListeners(ffepInstance) {\n  // console.log(\"Setting up form handling event listeners...\");\n\n  // Handle submit button click\n  if (ffepInstance.submitButton) {\n    ffepInstance.submitButton.addEventListener(\"click\", (e) => {\n      e.preventDefault(); // Prevent default anchor tag behavior\n      // console.log(\"Submit button clicked via formHandler. Autocomplete visible?\", ffepInstance.isAutocompleteVisible);\n      // Only submit if autocomplete is not showing suggestions\n      if (!ffepInstance.isAutocompleteVisible) {\n        ffepInstance.triggerFormSubmit(); // Call the main instance's submit logic\n      }\n    });\n  } else {\n    console.warn(\"Submit button (#ffep-submit) not found. Form submission via button click disabled.\");\n  }\n\n  // Handle enter key on input\n  if (ffepInstance.addressInput) {\n    ffepInstance.addressInput.addEventListener(\"keydown\", (e) => {\n      // console.log(`Keydown on input via formHandler: ${e.key}. Autocomplete visible? ${ffepInstance.isAutocompleteVisible}`);\n      // Let the ui.js handleKeydown manage Enter when autocomplete is visible\n      if (ffepInstance.isAutocompleteVisible) {\n        return; // ui.js keydown handler takes precedence for selection/submission\n      }\n\n      // Handle Enter for submission ONLY when autocomplete is hidden\n      if (e.key === \"Enter\") {\n        // console.log(\"Enter pressed (autocomplete hidden) via formHandler. Triggering submit.\");\n        e.preventDefault(); // Prevent potential default form submission\n        ffepInstance.triggerFormSubmit(); // Call the main instance's submit logic\n      }\n    });\n  } else {\n    // This case should theoretically not happen if init succeeded\n    console.error(\"Address input not found during form handler setup.\");\n  }\n  // console.log(\"Form handling event listeners setup complete.\");\n}\n",
    "import { SMARTY_WEBSITE_KEYS, ErrorTypes } from \"./constants.js\";\nimport { debounce } from \"./utils.js\";\nimport { CacheManager } from \"./cache.js\";\nimport { fetchSuggestions as apiFetchSuggestions } from \"./api.js\";\nimport { setupAutocomplete as uiSetupAutocomplete, showSuggestions as uiShowSuggestions, hideSuggestions as uiHideSuggestions } from \"./ui.js\";\nimport { setupFormEventListeners } from \"./formHandler.js\";\n\nclass FFEP {\n  constructor() {\n    // Core state\n    this.addressInput = null;\n    this.autocompleteContainer = null; // Managed by ui.js\n    this.submitButton = null;\n    this.errorElement = null;\n\n    // Autocomplete state\n    this.suggestions = [];\n    this.selectedIndex = -1;\n    this.isAutocompleteVisible = false;\n    this.lastQuery = \"\";\n\n    // Configuration & Services\n    this.smartyKey = this.getSmartyKey();\n    this.cacheManager = new CacheManager();\n    this.apiCallCount = 0;\n\n    // Debounced API call\n    this.debouncedFetchSuggestions = debounce(this.fetchAndShowSuggestions.bind(this), (query) => (query && query.length <= 4 ? 50 : 200));\n\n    // console.log(\"FFEP Constructor finished\");\n  }\n\n  getSmartyKey() {\n    const hostname = window.location.hostname;\n    // console.log(\"Hostname:\", hostname);\n    const key = hostname.includes(\".dev\") ? SMARTY_WEBSITE_KEYS.PDD : SMARTY_WEBSITE_KEYS.PDC;\n    // console.log(\"Selected Smarty Key:\", key ? \"Key Found\" : \"Key Missing!\");\n    return key;\n  }\n\n  init() {\n    // console.log(\"FFEP Init started\");\n    // Find the address input\n    this.addressInput = document.querySelector('[data-ffep=\"address\"]');\n    if (!this.addressInput) {\n      this.handleInitializationError('Input with data-ffep=\"address\" not found');\n      return;\n    }\n\n    // Find other essential elements\n    this.submitButton = document.querySelector(\"#ffep-submit\");\n    this.errorElement = document.querySelector(\".field-error\"); // Optional, might not exist\n    this.autocompleteContainer = document.querySelector(\".ffep-autocomplete\"); // Find container for UI module\n\n    if (!this.autocompleteContainer) {\n      // Don't throw error, just log and disable autocomplete\n      console.warn(\"Autocomplete container (.ffep-autocomplete) not found. Autocomplete disabled.\");\n    }\n\n    // console.log(\"Essential elements found:\", {\n    //     addressInput: !!this.addressInput,\n    //     submitButton: !!this.submitButton,\n    //     errorElement: !!this.errorElement,\n    //     autocompleteContainer: !!this.autocompleteContainer\n    // });\n\n    // Setup UI event listeners via ui.js if container exists\n    if (this.autocompleteContainer) {\n      uiSetupAutocomplete(this);\n      // console.log(\"Autocomplete UI setup complete\");\n    }\n\n    // Setup form submission logic using the new module\n    setupFormEventListeners(this);\n    // console.log(\"Form handling setup complete\");\n    // console.log(\"FFEP Init finished\");\n  }\n\n  handleInitializationError(message) {\n    const error = new Error(message);\n    error.name = ErrorTypes.INITIALIZATION;\n    console.error(`[${ErrorTypes.INITIALIZATION}] ${message}`);\n  }\n\n  // Renamed from handleSubmit to clarify role\n  triggerFormSubmit() {\n    // console.log(\"Triggering form submission...\");\n    try {\n      const addressValue = this.addressInput.value;\n      if (!addressValue || addressValue.length < 3) {\n        // Basic validation\n        console.warn(\"Submission blocked: Address input is too short.\");\n        // Optional: Show user feedback\n        if (this.errorElement) {\n          this.errorElement.textContent = \"Please enter a valid address.\";\n          this.errorElement.style.display = \"block\";\n        }\n        return;\n      }\n\n      const encodedAddress = encodeURIComponent(addressValue).replace(/%20/g, \"+\");\n      const targetTLD = window.location.hostname.includes(\".dev\") ? \"dev\" : \"com\";\n      const targetUrl = `https://home.point.${targetTLD}/?Enter+your+home+address=${encodedAddress}&address=${encodedAddress}`;\n\n      // console.log(\"Redirecting to:\", targetUrl);\n      // Use setTimeout to allow any pending UI updates or event listeners to complete\n      setTimeout(() => {\n        window.location.replace(targetUrl);\n      }, 0);\n    } catch (error) {\n      // console.error(\"Error during form submission trigger:\", error);\n      error.name = ErrorTypes.FORM_SUBMISSION;\n      console.error(`[${ErrorTypes.FORM_SUBMISSION}] Error during redirect:`, error);\n      // Show generic error to user\n      if (this.errorElement) {\n        this.errorElement.textContent = \"An error occurred. Please try again.\";\n        this.errorElement.style.display = \"block\";\n      }\n      uiHideSuggestions(this);\n    }\n  }\n\n  // --- Event Handlers (called by ui.js listeners or directly) ---\n\n  async handleInput(e) {\n    const query = e.target.value;\n    // console.log(\"Input event triggered. Query:\", query);\n    if (query.length < 3) {\n      uiHideSuggestions(this);\n      return;\n    }\n    // Use the debounced fetch + show function\n    await this.debouncedFetchSuggestions(query);\n  }\n\n  // Fetches suggestions using the API module and then tells the UI module to show them\n  async fetchAndShowSuggestions(query) {\n    // console.log(\"Executing debounced fetch & show for query:\", query);\n    if (!this.smartyKey) {\n      console.error(\"Smarty API key is missing. Cannot fetch suggestions.\");\n      return;\n    }\n    try {\n      const apiOptions = {\n        lastQuery: this.lastQuery,\n        suggestionsCount: this.suggestions.length,\n        apiCallCount: this.apiCallCount,\n        errorElement: this.errorElement,\n      };\n      const fetchedSuggestions = await apiFetchSuggestions(query, this.smartyKey, this.cacheManager, apiOptions);\n\n      // Update state based on API response\n      this.apiCallCount++; // Increment after successful or failed call handled by api.js\n      this.lastQuery = query; // Update last query regardless of result for optimization\n\n      if (fetchedSuggestions) {\n        this.suggestions = fetchedSuggestions;\n        if (this.suggestions.length > 0) {\n          // console.log(\"Suggestions received, showing UI.\");\n          uiShowSuggestions(this);\n        } else {\n          // console.log(\"No suggestions received, hiding UI.\");\n          uiHideSuggestions(this);\n        }\n      } else {\n        // Handle cases where apiFetchSuggestions returns null (e.g., query too short, error handled internally)\n        // console.log(\"API fetch returned null/empty, ensuring UI is hidden.\");\n        this.suggestions = [];\n        uiHideSuggestions(this);\n      }\n    } catch (error) {\n      // This catch block might be redundant if api.js handles all errors,\n      // but good for catching unexpected issues during the orchestration.\n      console.error(\"Error in fetchAndShowSuggestions orchestration:\", error);\n      this.suggestions = [];\n      uiHideSuggestions(this);\n    }\n  }\n\n  // Note: Other specific handlers (keydown, focus, clickOutside) are now primarily in ui.js\n  // They call methods like uiShowSuggestions, uiHideSuggestions, uiSelectSuggestion (which calls triggerFormSubmit),\n  // and triggerFormSubmit on the FFEP instance when needed.\n}\n\n// --- Initialization --- //\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  // console.log(\"DOM Content Loaded. Initializing FFEP...\");\n  try {\n    // Make FFEP instance available globally (consider alternative patterns if needed)\n    window.FFEPInstance = new FFEP();\n    window.FFEPInstance.init();\n    // console.log(\"FFEP Initialized successfully and attached to window.FFEPInstance\");\n  } catch (error) {\n    console.error(\"Critical error during FFEP initialization:\", error);\n  }\n});\n\n// Export the class for potential testing or advanced usage (though current setup relies on global instance)\nexport default FFEP;\n"
  ],
  "mappings": "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",
  "debugId": "2879A327585DA98764756E2164756E21",
  "names": []
}